# live-boot helper functions, used by live-boot on boot and by live-snapshot

if [ ! -x "/bin/fstype" ]
then
	# klibc not in path -> not in initramfs
	export PATH="${PATH}:/usr/lib/klibc/bin"
fi

# handle upgrade path from old udev (using udevinfo) to
# recent versions of udev (using udevadm info)
if [ -x /sbin/udevadm ]
then
	udevinfo='/sbin/udevadm info'
else
	udevinfo='udevinfo'
fi

root_overlay_label="full-ov"
custom_overlay_label="custom-ov"
root_snapshot_label="live-sn"
home_snapshot_label="home-sn"
persistence_list="live.persist"

Arguments ()
{
	PRESEEDS=""
	LOCATIONS=""

	for ARGUMENT in $(cat /proc/cmdline)
	do
		case "${ARGUMENT}" in
			skipconfig)
				NOACCESSIBILITY="Yes"
				NOFASTBOOT="Yes"
				NOFSTAB="Yes"
				NONETWORKING="Yes"

				export NOACCESSIBILITY NOFASTBOOT NOFSTAB NONETWORKING
				;;

			access=*)
				ACCESS="${ARGUMENT#access=}"
				export ACCESS
				;;

			console=*)
				DEFCONSOLE="${ARGUMENT#*=}"
				export DEFCONSOLE
				;;

			BOOTIF=*)
				BOOTIF="${x#BOOTIF=}"
				;;

			debug)
				DEBUG="Yes"
				export DEBUG

				set -x
				;;

			dhcp)
				# Force dhcp even while netbooting
				# Use for debugging in case somebody works on fixing dhclient
				DHCP="Force";
				export DHCP
				;;

			nodhcp)
				unset DHCP
				;;

			ethdevice=*)
				DEVICE="${ARGUMENT#ethdevice=}"
				ETHDEVICE="${DEVICE}"
				export DEVICE ETHDEVICE
				;;

			ethdevice-timeout=*)
				ETHDEV_TIMEOUT="${ARGUMENT#ethdevice-timeout=}"
				export ETHDEV_TIMEOUT
				;;

			fetch=*)
				FETCH="${ARGUMENT#fetch=}"
				export FETCH
				;;

			forcepersistentfsck)
				FORCEPERSISTENTFSCK="Yes"
				export FORCEPERSISTENTFSCK
				;;

			ftpfs=*)
				FTPFS="${ARGUMENT#ftpfs=}"
				export FTPFS
				;;

			httpfs=*)
				HTTPFS="${ARGUMENT#httpfs=}"
				export HTTPFS
				;;

			iscsi=*)
				ISCSI="${ARGUMENT#iscsi=}"
				#ip:port - separated by ;
				ISCSI_PORTAL="${ISCSI%;*}"
				if echo "${ISCSI_PORTAL}" | grep -q , ; then
					ISCSI_SERVER="${ISCSI_PORTAL%,*}"
					ISCSI_PORT="${ISCSI_PORTAL#*,}"
				fi
				#target name
				ISCSI_TARGET="${ISCSI#*;}"
				export ISCSI ISCSI_PORTAL ISCSI_TARGET ISCSI_SERVER ISCSI_PORT
				;;

			isofrom=*|fromiso=*)
				FROMISO="${ARGUMENT#*=}"
				export FROMISO
				;;

			ignore_uuid)
				IGNORE_UUID="Yes"
				export IGNORE_UUID
				;;

			integrity-check)
				INTEGRITY_CHECK="Yes"
				export INTEGRITY_CHECK
				;;

			ip=*)
				STATICIP="${ARGUMENT#ip=}"

				if [ -z "${STATICIP}" ]
				then
					STATICIP="frommedia"
				fi

				export STATICIP
				;;

			live-getty)
				LIVE_GETTY="1"
				export LIVE_GETTY
				;;

			live-media=*|bootfrom=*)
				LIVE_MEDIA="${ARGUMENT#*=}"
				export LIVE_MEDIA
				;;

			live-media-encryption=*|encryption=*)
				LIVE_MEDIA_ENCRYPTION="${ARGUMENT#*=}"
				export LIVE_MEDIA_ENCRYPTION
				;;

			live-media-offset=*)
				LIVE_MEDIA_OFFSET="${ARGUMENT#live-media-offset=}"
				export LIVE_MEDIA_OFFSET
				;;

			live-media-path=*)
				LIVE_MEDIA_PATH="${ARGUMENT#live-media-path=}"
				export LIVE_MEDIA_PATH
				;;

			live-media-timeout=*)
				LIVE_MEDIA_TIMEOUT="${ARGUMENT#live-media-timeout=}"
				export LIVE_MEDIA_TIMEOUT
				;;

			module=*)
				MODULE="${ARGUMENT#module=}"
				export MODULE
				;;

			netboot=*)
				NETBOOT="${ARGUMENT#netboot=}"
				export NETBOOT
				;;

			nfsopts=*)
				NFSOPTS="${ARGUMENT#nfsopts=}"
				export NFSOPTS
				;;

			nfscow=*)
				NFS_COW="${ARGUMENT#nfscow=}"
				export NFS_COW
				;;

			noaccessibility)
				NOACCESSIBILITY="Yes"
				export NOACCESSIBILITY
				;;

			nofastboot)
				NOFASTBOOT="Yes"
				export NOFASTBOOT
				;;

			nofstab)
				NOFSTAB="Yes"
				export NOFSTAB
				;;

			nonetworking)
				NONETWORKING="Yes"
				export NONETWORKING
				;;

			ramdisk-size=*)
				ramdisk_size="${ARGUMENT#ramdisk-size=}"
				;;

			swapon)
				SWAPON="Yes"
				export SWAPON
				;;

			persistent)
				PERSISTENT="Yes"
				export PERSISTENT
				;;

			persistent-encryption=*)
				PERSISTENT_ENCRYPTION="${ARGUMENT#*=}"
				export PERSISTENT_ENCRYPTION
				;;

			persistent-media=*)
				PERSISTENT_MEDIA="${ARGUMENT#*=}"
				export PERSISTENT_MEDIA
				;;
			persistent-method=*)
				PERSISTENT_METHOD="${ARGUMENT#*=}"
				export PERSISTENT_METHOD
				;;

			persistent-path=*)
				PERSISTENT_PATH="${ARGUMENT#persistent-path=}"
				export PERSISTENT_PATH
				;;
			persistent-read-only)
				PERSISTENT_READONLY="Yes"
				export PERSISTENT_READONLY
				;;

			persistent-storage=*)
				PERSISTENT_STORAGE="${ARGUMENT#persistent-storage=}"
				export PERSISTENT_STORAGE
				;;

			persistent-subtext=*)
				root_overlay_label="${root_overlay_label}-${ARGUMENT#persistent-subtext=}"
				custom_overlay_label="${custom_overlay_label}-${ARGUMENT#persistent-subtext=}"
				root_snapshot_label="${root_snapshot_label}-${ARGUMENT#persistent-subtext=}"
				home_snapshot_label="${home_snapshot_label}-${ARGUMENT#persistent-subtext=}"
				;;

			nopersistent)
				NOPERSISTENT="Yes"
				export NOPERSISTENT
				;;

			noprompt)
				NOPROMPT="Yes"
				export NOPROMPT
				;;

			noprompt=*)
				NOPROMPT="${ARGUMENT#noprompt=}"
				export NOPROMPT
				;;

			quickusbmodules)
				QUICKUSBMODULES="Yes"
				export QUICKUSBMODULES
				;;

			preseed/file=*|file=*)
				LOCATIONS="${ARGUMENT#*=} ${LOCATIONS}"
				export LOCATIONS
				;;

			nopreseed)
				NOPRESEED="Yes"
				export NOPRESEED
				;;

			*/*=*)
				question="${ARGUMENT%%=*}"
				value="${ARGUMENT#*=}"
				PRESEEDS="${PRESEEDS}\"${question}=${value}\" "
				export PRESEEDS
				;;

			showmounts)
				SHOWMOUNTS="Yes"
				export SHOWMOUNTS
				;;

			silent)
				SILENT="Yes"
				export SILENT
				;;

			todisk=*)
				TODISK="${ARGUMENT#todisk=}"
				export TODISK
				;;

			toram)
				TORAM="Yes"
				export TORAM
				;;

			toram=*)
				TORAM="Yes"
				MODULETORAM="${ARGUMENT#toram=}"
				export TORAM MODULETORAM
				;;

			exposedroot)
				EXPOSED_ROOT="Yes"
				export EXPOSED_ROOT
				;;

			plainroot)
				PLAIN_ROOT="Yes"
				export PLAIN_ROOT
				;;

			skipunion)
				SKIP_UNION_MOUNTS="Yes"
				export SKIP_UNION_MOUNTS
				;;

			root=*)
				ROOT="${ARGUMENT#root=}"
				export ROOT
				;;

			union=*)
				UNIONTYPE="${ARGUMENT#union=}"
				export UNIONTYPE
				;;
		esac
	done

	# sort of compatibility with netboot.h from linux docs
	if [ -z "${NETBOOT}" ]
	then
		if [ "${ROOT}" = "/dev/nfs" ]
		then
			NETBOOT="nfs"
			export NETBOOT
		elif [ "${ROOT}" = "/dev/cifs" ]
		then
			NETBOOT="cifs"
			export NETBOOT
		fi
	fi

	if [ -z "${MODULE}" ]
	then
		MODULE="filesystem"
		export MODULE
	fi

	if [ -z "${UNIONTYPE}" ]
	then
		UNIONTYPE="aufs"
		export UNIONTYPE
	fi

	if [ -z "${PERSISTENT_ENCRYPTION}" ]
	then
		PERSISTENT_ENCRYPTION="none"
		export PERSISTENT_ENCRYPTION
	elif echo ${PERSISTENT_ENCRYPTION} | grep -qe "\<luks\>"
	then
		if ! modprobe dm-crypt
		then
			log_warning_msg "Unable to load module dm-crypt"
			PERSISTENT_ENCRYPTION=$(echo ${PERSISTENT_ENCRYPTION} | sed -e 's/\<luks,\|,\?luks$//g')
			export PERSISTENT_ENCRYPTION
		fi

		if [ ! -x /lib/cryptsetup/askpass ] || [ ! -x /sbin/cryptsetup ]
		then
			log_warning_msg "cryptsetup in unavailable"
			PERSISTENT_ENCRYPTION=$(echo ${PERSISTENT_ENCRYPTION} | sed -e 's/\<luks,\|,\?luks$//g')
			export PERSISTENT_ENCRYPTION
		fi
	fi

	if [ -z "${PERSISTENT_METHOD}" ]
	then
		PERSISTENT_METHOD="snapshot,overlay"
		export PERSISTENT_METHOD
	fi

	if [ -z "${PERSISTENT_STORAGE}" ]
	then
		PERSISTENT_STORAGE="filesystem,file"
		export PERSISTENT_STORAGE
	fi
}

sys2dev ()
{
	sysdev=${1#/sys}
	echo "/dev/$($udevinfo -q name -p ${sysdev} 2>/dev/null|| echo ${sysdev##*/})"
}

subdevices ()
{
	sysblock=${1}
	r=""

	for dev in "${sysblock}"/* "${sysblock}"
	do
		if [ -e "${dev}/dev" ]
		then
			r="${r} ${dev}"
		fi
	done

	echo ${r}
}

storage_devices()
{
	black_listed_devices="${1}"
	white_listed_devices="${2}"

	for sysblock in $(echo /sys/block/* | tr ' ' '\n' | grep -vE "loop|ram|fd")
	do
		fulldevname=$(sys2dev "${sysblock}")

		if echo "${black_listed_devices}" | grep -qe "\<${fulldevname}\>" || \
			[ -n "${white_listed_devices}" ] && \
			echo "${white_listed_devices}" | grep -qve "\<${fulldevname}\>"
		then
			# skip this device entirely
			continue
		fi

		for dev in $(subdevices "${sysblock}")
		do
			devname=$(sys2dev "${dev}")

			if echo "${black_listed_devices}" | grep -qe "\<${devname}\>"
			then
				# skip this subdevice
				continue
			else
				echo "${devname}"
			fi
		done
	done
}

is_supported_fs ()
{
	fstype="${1}"

	# Validate input first
	if [ -z "${fstype}" ]
	then
		return 1
	fi

	# Try to look if it is already supported by the kernel
	if grep -q ${fstype} /proc/filesystems
	then
		return 0
	else
		# Then try to add support for it the gentle way using the initramfs capabilities
		modprobe ${fstype}
		if grep -q ${fstype} /proc/filesystems
		then
			return 0
		# Then try the hard way if /root is already reachable
		else
			kmodule="/root/lib/modules/`uname -r`/${fstype}/${fstype}.ko"
			if [ -e "${kmodule}" ]
			then
				insmod "${kmodule}"
				if grep -q ${fstype} /proc/filesystems
				then
					return 0
				fi
			fi
		fi
	fi

	return 1
}

get_fstype ()
{
	/sbin/blkid -s TYPE -o value $1 2>/dev/null
}

where_is_mounted ()
{
	device=${1}

	if grep -q "^${device} " /proc/mounts
	then
		# return the first found
		grep -m1 "^${device} " /proc/mounts | cut -f2 -d ' '
	fi
}

lastline ()
{
	while read lines
	do
		line=${lines}
	done

	echo "${line}"
}

base_path ()
{
	testpath="${1}"
	mounts="$(awk '{print $2}' /proc/mounts)"
	testpath="$(busybox realpath ${testpath})"

	while true
	do
		if echo "${mounts}" | grep -qs "^${testpath}"
		then
			set -- $(echo "${mounts}" | grep "^${testpath}" | lastline)
			echo ${1}
			break
		else
			testpath=$(dirname $testpath)
		fi
	done
}

fs_size ()
{
	# Returns used/free fs kbytes + 5% more
	# You could pass a block device as ${1} or the mount point as ${2}

	dev="${1}"
	mountp="${2}"
	used="${3}"

	if [ -z "${mountp}" ]
	then
		mountp="$(where_is_mounted ${dev})"

		if [ -z "${mountp}" ]
		then
			mountp="/mnt/tmp_fs_size"

			mkdir -p "${mountp}"
			mount -t $(get_fstype "${dev}") -o ro "${dev}" "${mountp}" || log_warning_msg "cannot mount -t $(get_fstype ${dev}) -o ro ${dev} ${mountp}"

			doumount=1
		fi
	fi

	if [ "${used}" = "used" ]
	then
		size=$(du -ks ${mountp} | cut -f1)
		size=$(expr ${size} + ${size} / 20 ) # FIXME: 5% more to be sure
	else
		# free space
		size="$(df -k | grep -s ${mountp} | awk '{print $4}')"
	fi

	if [ -n "${doumount}" ]
	then
		umount "${mountp}" || log_warning_msg "cannot umount ${mountp}"
		rmdir "${mountp}"
	fi

	echo "${size}"
}

load_keymap ()
{
	# Load custom keymap
	if [ -x /bin/loadkeys -a -r /etc/boottime.kmap.gz ]
	then
		loadkeys /etc/boottime.kmap.gz
	fi
}

setup_loop ()
{
	local fspath=${1}
	local module=${2}
	local pattern=${3}
	local offset=${4}
	local encryption=${5}
	local readonly=${6}

	# the output of setup_loop is evaluated in other functions,
	# modprobe leaks kernel options like "libata.dma=0"
	# as "options libata dma=0" on stdout, causing serious
	# problems therefor, so instead always avoid output to stdout
	modprobe -q -b "${module}" 1>/dev/null

	udevadm settle

	for loopdev in ${pattern}
	do
		if [ "$(cat ${loopdev}/size)" -eq 0 ]
		then
			dev=$(sys2dev "${loopdev}")
			options=''

			if [ -n "${readonly}" ]
			then
				if losetup --help 2>&1 | grep -q -- "-r\b"
				then
					options="${options} -r"
				fi
			fi

			if [ -n "${offset}" ] && [ 0 -lt "${offset}" ]
			then
				options="${options} -o ${offset}"
			fi

			if [ -z "${encryption}" ]
			then
				losetup ${options} "${dev}" "${fspath}"
			else
				# Loop AES encryption
				while true
				do
					load_keymap

					echo -n "Enter passphrase for root filesystem: " >&6
					read -s passphrase
					echo "${passphrase}" > /tmp/passphrase
					unset passphrase
					exec 9</tmp/passphrase
					/sbin/losetup ${options} -e "${encryption}" -p 9 "${dev}" "${fspath}"
					error=${?}
					exec 9<&-
					rm -f /tmp/passphrase

					if [ 0 -eq ${error} ]
					then
						unset error
						break
					fi

					echo
					echo -n "There was an error decrypting the root filesystem ... Retry? [Y/n] " >&6
					read answer

					if [ "$(echo "${answer}" | cut -b1 | tr A-Z a-z)" = "n" ]
					then
						unset answer
						break
					fi
				done
			fi

			echo "${dev}"
			return 0
		fi
	done

	panic "No loop devices available"
}

try_mount ()
{
	dev="${1}"
	mountp="${2}"
	opts="${3}"
	fstype="${4}"

	old_mountp="$(where_is_mounted ${dev})"

	if [ -n "${old_mountp}" ]
	then
		if [ "${opts}" != "ro" ]
		then
			mount -o remount,"${opts}" "${dev}" "${old_mountp}" || panic "Remounting ${dev} ${opts} on ${old_mountp} failed"
		fi

		mount -o bind "${old_mountp}" "${mountp}" || panic "Cannot bind-mount ${old_mountp} on ${mountp}"
	else
		if [ -z "${fstype}" ]
		then
			fstype=$(get_fstype "${dev}")
		fi
		mount -t "${fstype}" -o "${opts}" "${dev}" "${mountp}" || \
		( echo "SKIPPING: Cannot mount ${dev} on ${mountp}, fstype=${fstype}, options=${opts}" > live-boot.log && return 0 )
	fi
}

open_luks_device ()
{
	dev="${1}"
	name="$(basename ${dev})"
	opts="--key-file=-"
	if [ -n "${PERSISTENT_READONLY}" ]
	then
		opts="${opts} --readonly"
	fi

	load_keymap

	while true
	do
		/lib/cryptsetup/askpass "Enter passphrase for ${dev}: " | \
			/sbin/cryptsetup -T 1 luksOpen ${dev} ${name} ${opts}

		if [ 0 -eq ${?} ]
		then
			luks_device="/dev/mapper/${name}"
			echo ${luks_device}
			return 0
		fi

		echo >&6
		echo -n "There was an error decrypting ${dev} ... Retry? [Y/n] " >&6
		read answer

		if [ "$(echo "${answer}" | cut -b1 | tr A-Z a-z)" = "n" ]
		then
			return 2
		fi
	done
}

get_gpt_name () {
    local dev="${1}"
    /sbin/blkid -s PART_ENTRY_NAME -p -o value ${dev} 2>/dev/null
}

is_gpt_device () {
    local dev="${1}"
    [ "$(/sbin/blkid -s PART_ENTRY_SCHEME -p -o value ${dev} 2>/dev/null)" = "gpt" ]
}

probe_for_gpt_name ()
{
	local overlays="${1}"
	local snapshots="${2}"
	local dev="${3}"

	if ! is_gpt_device ${dev} || \
	   ( echo ${PERSISTENT_ENCRYPTION} | grep -qve "\<luks\>" && \
	     /sbin/cryptsetup isLuks ${dev} > /dev/null 2>&1 )
	then
		return
	fi
	for label in ${overlays} ${snapshots}
	do
		if [ "$(get_gpt_name ${dev})" = "${label}" ]
		then
			echo "${label}=${dev}"
		fi
	done
}

probe_for_fs_label () {
	local overlays="${1}"
	local snapshots="${2}"
	local dev="${3}"

	for label in ${overlays} ${snapshots}
	do
		if [ "$(/sbin/blkid -s LABEL -o value $dev 2>/dev/null)" = "${label}" ]
		then
			echo "${label}=${dev}"
		fi
	done
}

probe_for_file_name () {
	local overlays="${1}"
	local snapshots="${2}"
	local dev="${3}"

	local devfstype="$(get_fstype ${dev})"
	local backing="${rootmnt}/live/persistent/$(basename ${dev})"
	local ret=""
	if is_supported_fs ${devfstype} && mkdir -p "${backing}" && \
	   try_mount "${dev}" "${backing}" "rw" "${devfstype}"
	then
		for label in ${overlays}
		do
			path=${backing}/${PERSISTENT_PATH}${label}
			if [ -f "${path}" ]
			then
				local loopdev=$(setup_loop "${path}" "loop" "/sys/block/loop*")
				ret="${ret} ${label}=${loopdev}"
			fi
		done
		for label in ${snapshots}
		do
			for ext in squashfs cpio.gz ext2 ext3 ext4 jffs2
			do
				path="${PERSISTENT_PATH}${label}.${ext}"
				if [ -f "${backing}/${path}" ]
				then
					ret="${ret} ${label}=${dev}:${backing}:${path}"
				fi
			done
		done

		if [ -n "${ret}" ]
		then
			echo ${ret}
		else
			umount ${backing} > /dev/null 2>&1 || true
		fi
	fi
}

find_persistent_media ()
{
	# Scans devices for overlays and snapshots, and returns a whitespace
	# separated list of how to use them. Only overlays with a partition
	# label or file name in ${overlays} are returned, and ditto for
	# snapshots with labels in ${snapshots}.
	#
	# When scanning a LUKS device, the user will be asked to enter the
	# passphrase; on failure to enter it, or if no persistent partitions
	# or files were found, the LUKS device is closed.
	#
	# For a snapshot file the return value is ${label}=${snapdata}", where
	# ${snapdata} is the parameter used for try_snap().
	#
	# For all other cases (overlay/snapshot partition and overlay file) the
	# return value is "${label}=${device}", where ${device} a device that
	# can mount the content. In the case of an overlay file, the device
	# containing the file will remain mounted as a side-effect.
	#
	# No devices in ${black_listed_devices} will be scanned, and if
	# ${white_list_devices} is non-empty, only devices in it will be
	# scanned.

	local overlays="${1}"
	local snapshots="${2}"
	local black_listed_devices="${3}"
	local white_listed_devices="${4}"
	local ret=""

	for dev in $(storage_devices "${black_listed_devices}" "${white_listed_devices}")
	do
		local result=""

		local real_dev=""
		local luks_device=""
		# Check if it's a luks device; we'll have to open the device
		# in order to probe any filesystem it contains, like we do
		# below. do_custom_mounts() also depends on that any luks
		# device already has been opened.
		if echo ${PERSISTENT_ENCRYPTION} | grep -qe "\<luks\>" && \
		   /sbin/cryptsetup isLuks ${dev} >/dev/null 2>&1
		then
			if luks_device=$(open_luks_device "${dev}")
			then
				real_dev="${dev}"
				dev="${luks_device}"
			else
				# skip $dev since we failed/chose not to open it
				continue
			fi
		elif echo ${PERSISTENT_ENCRYPTION} | grep -qve "\<none\>"
		then
			# skip $dev since we don't allow unencrypted storage
			continue
		fi

		# Probe for matching GPT partition names or filesystem labels
		if echo ${PERSISTENT_STORAGE} | grep -qe "\<filesystem\>"
		then
			local gpt_dev="${dev}"
			if [ -n "${luks_device}" ]
			then
				# When we probe GPT partitions we need to look
				# at the real device, not the virtual, opened
				# luks device
				gpt_dev="${real_dev}"
			fi
			result=$(probe_for_gpt_name "${overlays}" "${snapshots}" ${gpt_dev})
			if [ -n "${result}" ]
			then
				ret="${ret} ${result}"
				continue
			fi

			result=$(probe_for_fs_label "${overlays}" "${snapshots}" ${dev})
			if [ -n "${result}" ]
			then
				ret="${ret} ${result}"
				continue
			fi
		fi

		# Probe for files with matching name on mounted partition
		if echo ${PERSISTENT_STORAGE} | grep -qe "\<file\>"
		then
			result=$(probe_for_file_name "${overlays}" "${snapshots}" ${dev})
			if [ -n "${result}" ]
			then
				ret="${ret} ${result}"
				continue
			fi
		fi

		# Close luks device if it isn't used
		if [ -z "${result}" ] && [ -n "${luks_device}" ] && \
		   /sbin/cryptsetup status "${luks_device}" 1> /dev/null 2>&1
		then
			/sbin/cryptsetup luksClose "${luks_device}"
		fi
	done

	if [ -n "${ret}" ]
	then
		echo ${ret}
	fi
}

get_mac ()
{
	mac=""

	for adaptor in /sys/class/net/*
	do
		status="$(cat ${adaptor}/iflink)"

		if [ "${status}" -eq 2 ]
		then
			mac="$(cat ${adaptor}/address)"
			mac="$(echo ${mac} | sed 's/:/-/g' | tr '[a-z]' '[A-Z]')"
		fi
	done

	echo ${mac}
}

is_luks()
{
    devname="${1}"
    if [ -x /sbin/cryptsetup ]
    then
	/sbin/cryptsetup isLuks "${devname}" 2>/dev/null || ret=${?}
	return ${ret}
    else
	return 1
    fi

}

removable_dev ()
{
	output_format="${1}"
	want_usb="${2}"
	ret=

	for sysblock in $(echo /sys/block/* | tr ' ' '\n' | grep -vE "/(loop|ram|dm-|fd)")
	do
		dev_ok=
		if [ "$(cat ${sysblock}/removable)" = "1" ]
		then
			if [ -z "${want_usb}" ]
			then
				dev_ok="yes"
			else
				if readlink ${sysblock} | grep -q usb
				then
					dev_ok="yes"
				fi
			fi
		fi

		if [ "${dev_ok}" = "yes" ]
		then
			case "${output_format}" in
				sys)
					ret="${ret} ${sysblock}"
					;;
				*)
					devname=$(sys2dev "${sysblock}")
					ret="${ret} ${devname}"
					;;
			esac
		fi
	done

	echo "${ret}"
}

removable_usb_dev ()
{
	output_format="${1}"

	removable_dev "${output_format}" "want_usb"
}

non_removable_dev ()
{
	output_format="${1}"
	ret=

	for sysblock in $(echo /sys/block/* | tr ' ' '\n' | grep -vE "/(loop|ram|dm-|fd)")
	do
		if [ "$(cat ${sysblock}/removable)" = "0" ]
		then
			case "${output_format}" in
				sys)
					ret="${ret} ${sysblock}"
					;;
				*)
					devname=$(sys2dev "${sysblock}")
					ret="${ret} ${devname}"
					;;
			esac
		fi
	done

	echo "${ret}"
}

link_files ()
{
	# create source's directory structure in dest, and recursively
	# create symlinks in dest to to all files in source. if mask
	# is non-empty, remove mask from all source paths when
	# creating links (will be necessary if we change root, which
	# live-boot normally does (into $rootmnt)).

	# remove multiple /:s and ensure ending on /
	local src_dir="$(echo "${1}"/ | sed -e 's|/\+|/|g')"
	local dest_dir="$(echo "${2}"/ | sed -e 's|/\+|/|g')"
	local src_mask="${3}"

	# This check can only trigger on the inital, non-recursive call since
	# we create the destination before recursive calls
	if [ ! -d "${dest_dir}" ];
	then
		log_warning_msg "Must link_files into a directory"
		return
	fi

	find "${src_dir}" -mindepth 1 -maxdepth 1 | while read x; do
		local src="${x}"
		local dest="${dest_dir}$(basename "${x}")"
		if [ -d "${src}" ];
		then
			if [ -z "$(ls -A "${src}")" ];
			then
				continue
			fi
			if [ ! -d "${dest}" ];
			then
				mkdir -p "${dest}"
				prev="$(dirname "${dest}")"
				chown --reference "${prev}" "${dest}"
				chmod --reference "${prev}" "${dest}"
			fi
			link_files "${src}" "${dest}" "${src_mask}"
		else
			if [ -n "${src_mask}" ]
			then
				src="$(echo ${src} | sed "s|^${src_mask}||")"
			fi
			rm -rf "${dest}" 2> /dev/null
			ln -s "${src}" "${dest}"
		fi
	done
}

do_union () {
	local unionmountpoint="${1}"	# directory where the union is mounted
	local unionrw="${2}"		# branch where the union changes are stored
	local unionro1="${3}"		# first underlying read-only branch (optional)
	local unionro2="${4}"		# second underlying read-only branch (optional)

	if [ "${UNIONTYPE}" = "aufs" ]
	then
		rw_opt="rw"
		ro_opt="rr+wh"
		noxino_opt="noxino"
	elif [ "${UNIONTYPE}" = "unionfs-fuse" ]
	then
		rw_opt="RW"
		ro_opt="RO"
	else
		rw_opt="rw"
		ro_opt="ro"
	fi

	case "${UNIONTYPE}" in
		unionfs-fuse)
			unionmountopts="-o cow -o noinitgroups -o default_permissions -o allow_other -o use_ino -o suid"
			unionmountopts="${unionmountopts} ${unionrw}=${rw_opt}"
			if [ -n "${unionro1}" ]
			then
				unionmountopts="${unionmountopts}:${unionro1}=${ro_opt}"
			fi
			if [ -n "${unionro2}" ]
			then
				unionmountopts="${unionmountopts}:${unionro2}=${ro_opt}"
			fi
			( sysctl -w fs.file-max=391524 ; ulimit -HSn 16384
			unionfs-fuse ${unionmountopts} "${unionmountpoint}" ) && \
			( mkdir -p /run/sendsigs.omit.d
			pidof unionfs-fuse >> /run/sendsigs.omit.d/unionfs-fuse || true )
			;;

		overlayfs)
			# XXX: can unionro2 be used? (overlayfs only handles two dirs, but perhaps they can be chained?)
			# XXX: and can unionro1 be optional? i.e. can overlayfs skip lowerdir?
			unionmountopts="-o noatime,lowerdir=${unionro1},upperdir=${unionrw}"
			mount -t ${UNIONTYPE} ${unionmountopts} ${UNIONTYPE} "${unionmountpoint}"
			;;

		*)
			unionmountopts="-o noatime,${noxino_opt},dirs=${unionrw}=${rw_opt}"
			if [ -n "${unionro1}" ]
			then
				unionmountopts="${unionmountopts}:${unionro1}=${ro_opt}"
			fi
			if [ -n "${unionro2}" ]
			then
				unionmountopts="${unionmountopts}:${unionro2}=${ro_opt}"
			fi
			mount -t ${UNIONTYPE} ${unionmountopts} ${UNIONTYPE} "${unionmountpoint}"
			;;
	esac
}

get_custom_mounts () {
	# Side-effect: leaves $devices with live.persist mounted in ${rootmnt}/live/persistent
	# Side-effect: prints info to file $custom_mounts

	local devices="${1}"
	local custom_mounts="${2}" # print result to this file
	local rootmnt="${3}"       # should be set empty post-live-boot

	local bindings="/bindings.list"
	local links="/links.list"
	rm -rf ${bindings} ${links} 2> /dev/null
	local persistent_backing="${rootmnt}/live/persistent"

	for device in ${devices}
	do
		if [ ! -b "${device}" ]
		then
			continue
		fi
		local device_name="$(basename ${device})"
		local backing="${persistent_backing}/${device_name}"
		mkdir -p "${backing}"
		local device_fstype="$(get_fstype ${device})"
		if [ -z "${PERSISTENT_READONLY}" ]
		then
			device_mount_opts="rw,noatime"
		else
			device_mount_opts="ro,noatime"
		fi
		local device_used=""
		mount -t "${device_fstype}" -o "${device_mount_opts}" "${device}" "${backing}"
		local include_list="${backing}/${persistence_list}"
		if [ ! -r "${include_list}" ]
		then
			umount "${backing}"
			rmdir "${backing}"
			continue
		fi

		[ "${DEBUG}" = "Yes" ] && cp ${include_list} ${persistent_backing}/${persistence_list}.${device_name}
		while read source dest options # < ${include_list}
		do
			if echo ${source} | grep -qe "^[[:space:]]*\(#.*\)\?$"
			then
				# skipping empty or commented lines
				continue
			fi

			if echo ${dest} | grep -qe "^[^/]"
			then
				options="${dest}"
				dest="${source}"
			elif [ -z "${dest}" ]
			then
				dest="${source}"
			fi

			if echo ${dest} | grep -qe "^/\+$\|^/\+live\(/.*\)\?$"
			then
				# mounting on / or /live could cause trouble
				log_warning_msg "Skipping unsafe custom mount on ${dest}"
				continue
			fi

			for opt in $(echo ${options} | tr ',' ' ');
			do
				case "${opt}" in
					linkfiles|union)
						;;
					*)
						log_warning_msg "Skipping custom mount with unkown option: ${opt}"
						continue 2
						;;
				esac
			done

			# FIXME: handle case: we already have /a/b in
			# $bindings added from current $device, but
			# now we find /a -- /a should replace /a/b in
			# $bindings.

			# FIXME: handle case: we have /a in $bindings
			# from current $device, now we find /a/b, so
			# we skip /a/b

			# ensure that no multiple-/ occur in paths
			local full_source="$(echo ${backing}/${source}/ | sed -e 's|/\+|/|g')"
			local full_dest="$(echo ${rootmnt}/${dest}/ | sed -e 's|/\+|/|g')"
			device_used="yes"
			if echo ${options} | grep -qe "\<linkfiles\>";
			then
				echo "${full_source} ${full_dest} ${options}" >> ${links}
			else
				echo "${full_source} ${full_dest} ${options}" >> ${bindings}
			fi
		done < ${include_list}

		if [ -z "${device_used}" ]
		then
			# this device was not used for / earlier, or
			# custom mount point now, so it's useless
			umount "${backing}"
			rmdir "${backing}"
		fi
	done

	# We sort the list according to destination so we're sure that
	# we won't hide a previous mount. We also ignore duplicate
	# destinations in a more or less arbitrary way.
	[ -e "${bindings}" ] && sort -k2 -sbu ${bindings} >> ${custom_mounts} && rm ${bindings}

	# After all mounts are considered we add symlinks so they
	# won't be hidden by some mount.
	[ -e "${links}" ] && sort -k2 -sbu ${links} >> ${custom_mounts} && rm ${links}
}

do_custom_mounts () {
	local custom_mounts="${1}" # the ouput from get_custom_mounts()
	local rootmnt="${2}"       # should be set empty post-live-boot

	while read source dest options # < ${custom_mounts}
	do
		local opt_linkfiles=""
		local opt_union=""
		for opt in $(echo ${options} | tr ',' ' ');
		do
			 case "${opt}" in
				linkfiles)
					opt_linkfiles="yes"
					;;
				union)
					opt_union="yes"
					;;
			esac
		done

		if mountpoint -q "${dest}";
		then
			log_warning_msg "Skipping custom mount ${source} on ${dest}: destination is already a mount point"
			continue
		fi

		# FIXME: we don't handle already existing
		# non-directory files in the paths of both $source and
		# $dest.

		if [ ! -d "${dest}" ]
		then
			# if ${dest} is in /home/$user, try fixing
			# proper ownership
			# FIXME: this should really be handled by
			# live-config since we don't know for sure
			# which uid a certain user has until then
			if echo ${dest} | grep -qe "^${rootmnt}/*home/\+[^/]\+"
			then
				path="/"
				for dir in $(echo ${dest} | sed -e 's|/\+| |g')
				do
					path=${path}/${dir}
					if [ ! -e ${path} ]
					then
						mkdir -p ${path}
						# assume that the intended user is the first, which is usually the case
						chown 1000:1000 ${path}
					fi
				done
			else
				mkdir -p ${dest}
			fi
		fi

		# if ${source} doesn't exist on our persistent media
		# we bootstrap it with $dest from the live filesystem.
		# this both makes sense and is critical if we're
		# dealing with /etc or other system dir.
		if [ ! -d "${source}" ]
		then
			if [ -n "${PERSISTENT_READONLY}" ] || [ -n "${opt_linkfiles}" ]
			then
				continue
			elif [ -n "${opt_union}" ]
			then
				# union's don't need to be bootstrapped
				mkdir "${source}"
			else
				# ensure that $dest is not copied *into* $source
				mkdir -p "$(dirname ${source})"
				cp -a "${dest}" "${source}"
			fi
		fi

		rofs_dest_backing=""
		for d in ${rootmnt}/live/rofs/*
		do
			if [ -n "${rootmnt}" ]
			then
				rofs_dest_backing="${d}/$(echo ${dest} | sed -e "s|${rootmnt}||")"
			else
				rofs_dest_backing="${d}/${dest}"

			fi
			if [ -d "${rofs_dest_backing}" ]
			then
				break
			else
				rofs_dest_backing=""
			fi
		done

		if [ -z "${PERSISTENT_READONLY}" ]
		then
			if [ -n "${opt_linkfiles}" ]
			then
				links_source="${source}"
				links_dest="${dest}"
			elif [ -n "${opt_union}" ]
			then
				do_union ${dest} ${source} ${rofs_dest_backing}
			else
				mount --bind "${source}" "${dest}"
			fi
		else
			if [ -n "${opt_linkfiles}" ]
			then
				links_dest="${dest}"
				dest="$(mktemp -d ${persistent_backing}/links_source-XXXXXX)"
				links_source="${dest}"
			fi
			if [ -n "${rootmnt}" ]
			then
				cow_dir="$(echo ${dest} | sed -e "s|${rootmnt}|/cow/|")"
			else
				cow_dir="/live/cow/${dest}"
			fi
			mkdir -p ${cow_dir}
			do_union ${dest} ${cow_dir} ${source} ${rofs_dest_backing}
		fi

		if [ -n "${opt_linkfiles}" ]
		then
			link_files "${links_source}" "${links_dest}" "${rootmnt}"
		fi

		PERSISTENCE_IS_ON="1"
		export PERSISTENCE_IS_ON
	done < ${custom_mounts}
}
