#!/bin/sh

# set -e

export PATH=/root/usr/bin:/root/usr/sbin:/root/bin:/root/sbin:/usr/bin:/usr/sbin:/bin:/sbin

mountpoint=/live_media

root_persistence="casper-rw"
home_persistence="home-rw"
root_snapshot="casper-sn"
home_snapshot="home-sn"

USERNAME="casper"
USERFULLNAME="Live session user"
HOST="live"
BUILD_SYSTEM="Debian"

mkdir -p $mountpoint

[ -f /etc/casper.conf ] && . /etc/casper.conf

export USERNAME USERFULLNAME HOST BUILD_SYSTEM

if [ "${BUILD_SYSTEM}" == "Ubuntu" ]; then
    MP_QUIET="-Q"
else
    MP_QUIET="-q"
fi

parse_cmdline ()
{
    # looking for casper specifics options as kernel parameters
    for x in $(cat /proc/cmdline); do
        case $x in
            userfullname=*)
                export USERFULLNAME=${x#userfullname=}
                export CASPERCONF="changed"
                ;;
            host=*)
                export HOST=${x#host=}
                export CASPERCONF="changed"
                ;;
            username=*)
                export USERNAME=${x#username=}
                export CASPERCONF="changed"
                ;;
            netboot*)
                export NETBOOT=${x#netboot=} ;;
            toram)
                export TORAM=1 ;;
            todisk=)
                export TODISK=${x#todisk=} ;;
            showmounts)
                export SHOWMOUNTS=1 ;;
            persistent)
                export PERSISTENT=1 ;;
            ip*)
                STATICIP=${x#ip=}
                if [ "${STATICIP}" == "" ]; then
                    STATICIP="frommedia"
                fi
                export STATICIP ;;
            casper-getty)
                export CASPERGETTY=1 ;;
            console=*)
                export DEFCONSOLE=$(sed -e 's%.*console=%console=%' /proc/cmdline) ;;
            bootfrom=*)
                export LIVEMEDIA=${x#bootfrom=} ;;
            live-media=*)
                export LIVEMEDIA=${x#live-media=} ;;
            debian-installer/locale=*)
                export LOCALE=${x#debian-installer/locale=} ;;
            locale=*)
                export LOCALE=${x#locale=} ;;
            kbd-chooser/method=*)
                export KBD=${x#kbd-chooser/method=} ;;
            keyb=*)
                export KBD=${x#kbd=} ;;
            console-setup/layoutcode=*)
                export CSLAYOUT=${x#console-setup/layoutcode=} ;;
            console-setup/variantcode=*)
                export CSVARIANT=${x#console-setup/variantcode=} ;;
            console-setup/modelcode=*)
                export CSMODEL=${x#console-setup/modelcode=} ;;
        esac
    done

    # sort of compatibility with netboot.h from linux docs
    if [ -z "${NETBOOT}" ]; then
        if [ "${ROOT}" == "/dev/nfs" ]; then
            NETBOOT="nfs"
            export NETBOOT
        elif [ "${ROOT}" == "/dev/cifs" ]; then
            NETBOOT="cifs"
            export NETBOOT
        fi
    fi
}

is_casper_path() {
    path=$1
    if [ -d "$path/casper" ]; then
        if [ "$(echo $path/casper/*.cloop)" != "$path/casper/*.cloop" ] ||
            [ "$(echo $path/casper/*.squashfs)" != "$path/casper/*.squashfs" ] ||
            [ "$(echo $path/casper/*.ext2)" != "$path/casper/*.ext2" ] ||
            [ "$(echo $path/casper/*.dir)" != "$path/casper/*.dir" ]; then
            return 0
        fi
    fi
    return 1
}

subdevices() {
    sysblock=$1
    r=""
    for dev in "${sysblock}" "${sysblock}"/*; do
        if [ -e "${dev}/dev" ]; then
            r="${r} ${dev}"
        fi
    done
    echo ${r}
}

get_backing_device() {
    case "$1" in
        *.cloop)
            echo $(setup_loop "$1" "cloop" "/sys/block/cloop*")
            ;;
        *.squashfs|*.ext2)
            echo $(setup_loop "$1" "loop" "/sys/block/loop*")
            ;;
        *.dir)
            echo "directory"
            ;;
        *)
            panic "Unrecognized casper filesystem: $1"
            ;;
    esac
}

match_files_in_dir() {
    # Does any files match pattern $1 ?

    local pattern="$1"
    if [ "$(echo $pattern)" != "$pattern" ]; then
        return 0
    fi
    return 1
}

mount_images_in_directory() {
    directory="$1"
    rootmnt="$2"
    if match_files_in_dir "$directory/casper/*.cloop"; then
        # Let's hope there's just one matching *.cloop... FIXME
        setup_devmapper $(get_backing_device "$directory/casper/*.cloop") "$rootmnt"
    elif match_files_in_dir "$directory/casper/*.squashfs" || 
        match_files_in_dir "$directory/casper/*.ext2" ||
        match_files_in_dir "$directory/casper/*.dir"; then
        setup_unionfs "$directory/casper" "$rootmnt"
    else
        :
    fi
}

sys2dev() {
    sysdev=${1#/sys}
    echo "/dev/$(udevinfo -q name -p ${sysdev} 2>/dev/null|| echo ${sysdev##*/})"
}

setup_loop() {
    local fspath=$1
    local module=$2
    local pattern=$3

    modprobe "${MP_QUIET}" -b "$module"
    udevsettle

    for loopdev in $pattern; do
        if [ "$(cat $loopdev/size)" -eq 0 ]; then
            dev=$(sys2dev "${loopdev}")
            losetup "$dev" "$fspath"
            echo "$dev"
            return 0
        fi
    done
    panic "No loop devices available"
}

get_fstype() {
    local FSTYPE
    local FSSIZE
    eval $(fstype < $1)
    if [ "$FSTYPE" != "unknown" ]; then
        echo $FSTYPE
        return 0
    fi
    /lib/udev/vol_id -t $1 2>/dev/null
}

setup_devmapper() {
    backdev="$1"
    rootmnt="$2"

    modprobe "${MP_QUIET}" -b dm-mod
    COW_DEVICE=/dev/ram1
    COW_NAME="casper-cow"

    BACKING_FILE_SIZE=$(blockdev --getsize "$backdev")
    MAX_COW_SIZE=$(blockdev --getsize "$COW_DEVICE")
    CHUNK_SIZE=8 # sectors

    if [ -z "$COW_SIZE" -o "$COW_SIZE" -gt "$MAX_COW_SIZE" ]; then
        COW_SIZE=$MAX_COW_SIZE
    fi

    echo "0 $COW_SIZE linear $COW_DEVICE 0" | dmsetup create $COW_NAME

    echo "0 $BACKING_FILE_SIZE snapshot $backdev /dev/mapper/$COW_NAME p $CHUNK_SIZE" | \
        dmsetup create casper-snapshot
    if [ "$(get_fstype $backdev)" = "unknown" ]; then
        panic "Unknown file system type on $backdev"
    fi
    mount -t $(get_fstype "$backdev") /dev/mapper/casper-snapshot $rootmnt || panic "Can not mount /dev/mapper/casper/snapshot on $rootmnt"

    mkdir -p "$rootmnt/rofs"
    echo "0 $BACKING_FILE_SIZE linear $backdev 0" | dmsetup create casper-backing
    mount -t $(get_fstype "$backdev") /dev/mapper/casper-backing "$rootmnt/rofs"
}

is_nice_device() {
    sysfs_path="${1#/sys}"
    if /lib/udev/path_id "${sysfs_path}" | grep -E -q "ID_PATH=(usb|pci-[^-]*-[ide|scsi|usb])"; then
        return 0
    fi
    return 1
}

is_supported_fs ()
{
    # FIXME: do something better like the scan of supported filesystems
    fstype="${1}"
    case ${fstype} in
        vfat|iso9660|udf|ext2|ext3|ntfs)
            return 0
            ;;
    esac
    return 1
}

where_is_mounted() {
    device=$1
    if grep -q "^$device " /proc/mounts; then
        grep "^$device " /proc/mounts | read d mountpoint rest
        echo $mountpoint
        return 0
    fi
    return 1
}

used_fs_size ()
{
    # Returns used fs kbytes + 5% more
    # You could pass a block device as $1 or the mount point as $2

    dev="${1}"
    mountp="${2}"

    if [ -z "${mountp}" ]; then
        mountp=$(where_is_mounted "${dev}")
        if [ "$?" -gt 0 ]; then
            mountp=/mnt/tmp_fs_size
            mkdir -p "${mountp}"
            mount -t $(get_fstype "${dev}") -o ro "${dev}" "${mountp}"
            doumount=1
        fi
    fi

    size=$(du -ks ${mountp} | cut -f1)
    size=$(expr ${size} + ${size}/20 ) # FIXME: 5% more to be sure
    needed_space=$(expr ${size} * 1024)

    if [ ! -z "${doumount}" ]; then
        umount "${mountp}"
        rmdir "${mountp}"
    fi
    echo "${needed_space}"
}

copy_live_to() {
    copyfrom="${1}"
    copytodev="${2}"
    copyto="${copyfrom}_swap"

    size=$(used_fs_size "null" "${copyfrom}")

    if [ "${copytodev}" = "ram" ]; then
        # copying to ram:
        freespace=$( expr $(awk '/MemFree/{print $2}' /proc/meminfo) + $( cat /proc/meminfo | grep Cached | head -n 1 | awk '/Cached/{print $2}' - ) )
        mount_options="-o size=${size}k"
        free_string="memory"
        fstype="tmpfs"
        dev="/dev/shm"
    else
        # it should be a writable block device
        if [ -b "${copytodev}" ]; then
            free_string="space"
            freespace="$(df -k ${copytodev} | grep -s ${copytodev} | awk '{print $4}')"
            fstype="$(get_fstype ${devname})"
            dev="${copytodev}"
        else
            return 1
        fi
    fi
    if [ ! ${freespace} -lt ${size}  ] ; then
        [ "$quiet" != "y" ] && log_begin_msg "Not enough free ${free_string} to copy live media in ${copytodev}."
        [ "$quiet" != "y" ] && log_end_msg
        return 1
    fi

    # begin copying..
    [ "$quiet" != "y" ] && log_begin_msg "Copying live media to ${copytodev}..." 
    mkdir "${copyto}"
    mount -t "${fstype}" ${mount_options} "${dev}" "${copyto}"
    cp -a ${copyfrom}/* ${copyto} # "cp -a" from busybox also copies hidden files
    umount ${copyfrom}
    mount -r -o move ${copyto} ${copyfrom}
    rmdir ${copyto}
    [ "$quiet" != "y" ] && log_end_msg
    return 0
}

try_mount ()
{
    dev="${1}"
    mountp="${2}"
    opts="${3}"

    if where_is_mounted ${dev} > /dev/null; then
        mount -o remount,"${opts}" ${dev} $(where_is_mounted ${dev}) || panic "Remounting failed"
        mount -o bind $(where_is_mounted ${dev}) ${mountp} || panic "Cannot bind-mount"
    else
        mount -t $(get_fstype "${dev}") -o "${opts}" "${dev}" "${mountp}" || panic "Cannot mount ${dev} on ${mountp}"
    fi
}

find_cow_device() {
    pers_label="${1}"
    cow_backing="/${pers_label}-backing"
    for sysblock in $(echo /sys/block/* | tr ' ' '\n' | grep -v loop); do
        for dev in $(subdevices "${sysblock}"); do
            devname=$(sys2dev "${dev}")
            if [ "$(/lib/udev/vol_id -l $devname 2>/dev/null)" = "${pers_label}" ]; then
                echo "$devname"
                return
            elif [ "$(get_fstype ${devname})" = "vfat" ]; then # FIXME: all supported block devices should be scanned
                mkdir -p "${cow_backing}"
                try_mount "${devname}" "${cow_backing}" "rw"
                if [ -e "${cow_backing}/${pers_label}" ]; then
                    echo $(setup_loop "${cow_backing}/${pers_label}" "loop" "/sys/block/loop*")
                    return 0
                else
                    umount ${cow_backing}
                fi
            fi
        done
    done
}

find_files()
# return the first of $filenames found on vfat and ext2 devices
# FIXME: merge with above function
{
    filenames="${1}"
    snap_backing="/snap-backing"
    for sysblock in $(echo /sys/block/* | tr ' ' '\n' | grep -v loop); do
        for dev in $(subdevices "${sysblock}"); do
            devname=$(sys2dev "${dev}")
            devfstype="$(get_fstype ${devname})"
            if [ "${devfstype}" = "vfat" ] ||  [ "${devfstype}" = "ext2" ] ; then # FIXME: all supported block devices should be scanned
                mkdir -p "${snap_backing}"
                try_mount "${devname}" "${snap_backing}" "ro"
                for filename in ${filenames}; do
                    if [ -e "${snap_backing}/${filename}" ]; then
                        echo "${devname} ${snap_backing} ${filename}"
                        return 0
                    fi
                done
                umount ${snap_backing}
            fi
        done
    done
}

do_netmount() {
    rc=1

    modprobe "${MP_QUIET}" af_packet # For DHCP

    ipconfig ${DEVICE} /tmp/net-${DEVICE}.conf

    if [ "${NFSROOT}" = "auto" ]; then
        NFSROOT=${ROOTSERVER}:${ROOTPATH}
    fi

    [ "$quiet" != "y" ] && log_begin_msg "Trying netboot from ${NFSROOT}"

    if [ "${NETBOOT}" != "nfs" ] && do_cifsmount ; then
        rc=0
    elif do_nfsmount ; then
        NETBOOT="nfs"
        export NETBOOT
        rc=0
    fi

    [ "$quiet" != "y" ] && log_end_msg
    return ${rc}
}

do_nfsmount() {
    rc=1
    modprobe "${MP_QUIET}" nfs
    if [ -z "${NFSOPTS}" ]; then
        NFSOPTS=""
    fi

    [ "$quiet" != "y" ] && log_begin_msg "Trying nfsmount -o nolock -o ro ${NFSOPTS} ${NFSROOT} ${mountpoint}"
    # FIXME: This for loop is an ugly HACK round an nfs bug
    for i in 0 1 2 3 4 5 6 7 8 9 a b c d e f 10 11 12 13; do
        nfsmount -o nolock -o ro ${NFSOPTS} "${NFSROOT}" "${mountpoint}" && rc=0 && break
        sleep 1
    done
    return ${rc}
}

do_cifsmount() {
    rc=1
    if [ -x "/sbin/mount.cifs" ]; then
        if [ -z "${NFSOPTS}" ]; then
            CIFSOPTS="-ouser=root,password="
        else
            CIFSOPTS="${NFSOPTS}"
        fi

        [ "$quiet" != "y" ] && log_begin_msg "Trying mount.cifs ${NFSROOT} ${mountpoint} ${CIFSOPTS}"
        modprobe "${MP_QUIET}" cifs

        if mount.cifs "${NFSROOT}" "${mountpoint}" "${CIFSOPTS}" ; then
            rc=0
        fi
    fi
    return ${rc}
}

do_snap_copy ()
{
    fromdev="${1}"
    todir="${2}"
    snap_type="${3}"

    size=$(used_fs_size "${fromdev}")

    if [ -b "${fromdev}" ]; then
        # look for free mem
        if [ ! -z "${HOMEMOUNTED}" ] && [ "${snap_type}" = "HOME" ]; then
            freespace="$(df -k ${copytodev} | grep -s ${copytodev} | awk '{print $4}')"
        else
            freespace=$( expr $(awk '/MemFree/{print $2}' /proc/meminfo) + $( cat /proc/meminfo | grep Cached | head -n 1 | awk '/Cached/{print $2}' - ))
        fi
        tomount="/mnt/tmpsnap"
        mkdir -p "${tomount}"
        mount -t $(get_fstype "${fromdev}") -o ro "${fromdev}" "${tomount}"
        cp -a "${tomount}"/* ${todir}
        umount "${tomount}"

        if echo ${fromdev} | grep -qs loop; then
            losetup -d "${fromdev}"
        fi

        return 0
    else
        return 1
        [ "$quiet" != "y" ] && log_warning_msg "Unable to find the snapshot ${snap_type} medium"
    fi
}

try_snap ()
{
    snap_label="${1}"
    snap_mount="${2}"
    snap_type="${3}"

    snapdata=$(find_files "${snap_label}.squashfs ${snap_label}.cpio.gz ${snap_label}.cpz ${snap_label}.gz")
    if [ ! -z "${snapdata}" ]; then
        snapdev=$(echo ${snapdata} | cut -f1 -d ' ')
        snapback=$(echo ${snapdata} | cut -f2 -d ' ')
        snapfile=$(echo ${snapdata} | cut -f3 -d ' ')
        if echo "${snapfile}" | grep -qs "squashfs" ; then
            # squashfs snapshot
            if ! do_snap_copy $( get_backing_device "${snapback}/${snapfile}" ) "${snap_mount}" "${snap_type}"; then
                 log_warning_msg "Impossible to include the ${snapfile} Snapshot"
                 return 1
            fi
        else
            # cpio.gz snapshot
            if ! (cd "${snap_mount}" && zcat "${snapback}/${snapfile}" | cpio -i -u -d ) ; then
                log_warning_msg "Impossible to include the ${snapfile} Snapshot"
                return 1
            fi
        fi
        umount "${snapback}"
    else # try pure snapshot device better elif.. rework all that routine
        if ! do_snap_copy $(find_cow_device "${snap_label}") "${snap_mount}" "${snap_type}"; then
            log_warning_msg "Impossible to include the ${snap_label} Snapshot"
            return 1
        fi
    fi
    echo "export ${snap_type}SNAP=${snapdev}:${snapfile}" >> /etc/casper.conf # for resync on reboot/halt
    return 0
}

do_others_persistences ()
{
    # directly mount /home
    # FIXME: add a custom mounts configurable system
    homecow=$(find_cow_device "${home_persistence}" )
    if [ -b "${homecow}" ]; then
        mount ${homecow} -t $(get_fstype "${homecow}") -o rw "${rootmnt}/home"
        export HOMEMOUNTED=1
    else
        [ "$quiet" != "y" ] && log_warning_msg "Unable to find the persistent home medium"
    fi

    # Look for snapshots to copy in
    try_snap "${root_snapshot}" "${rootmnt}" "ROOT"
    try_snap "${home_snapshot}" "${rootmnt}/home" "HOME"
}

setup_unionfs() {
    image_directory="$1"
    rootmnt="$2"

    modprobe "${MP_QUIET}" -b unionfs

    # run-init can't deal with images in a subdir, but we're going to
    # move all of these away before it runs anyway.  No, we're not,
    # put them in / since move-mounting them into / breaks mono and
    # some other apps.

    croot="/"

    # Let's just mount the read-only file systems first
    rofsstring=""
    rofslist=""
    if [ "${NETBOOT}" == "nfs" ] ; then
        roopt="nfsro" # go aroung a bug in nfs-unionfs locking
    else
        roopt="ro"
    fi

    mkdir -p "${croot}"
    for image_type in "ext2" "squashfs" "dir" ; do
        for image in "${image_directory}"/*."${image_type}"; do
            imagename=$(basename "${image}")
            if [ -d "${image}" ]; then
                # it is a plain directory: do nothing
                rofsstring="${image}=${roopt}:${rofsstring}"
                rofslist="${image} ${rofslist}"
            elif [ -f "${image}" ]; then
                backdev=$(get_backing_device "$image")
                fstype=$(get_fstype "${backdev}")
                if [ "${fstype}" = "unknown" ]; then
                    panic "Unknown file system type on ${backdev} (${image})"
                fi
                mkdir -p "${croot}/${imagename}"
                mount -t "${fstype}" -o ro "${backdev}" "${croot}/${imagename}" || panic "Can not mount $backdev ($image) on ${croot}/${imagename}" && rofsstring="${croot}/${imagename}=${roopt}:${rofsstring}" && rofslist="${croot}/${imagename} ${rofslist}"
            fi
        done
    done
    rofsstring=${rofsstring%:}

    mkdir -p /cow
    cowdevice="tmpfs"
    cow_fstype="tmpfs"

    # Looking for "${root_persistence}" device or file
    if [ ! -z "${PERSISTENT}" ]; then
        cowprobe=$(find_cow_device "${root_persistence}")
        if [ -b "${cowprobe}" ]; then
            cowdevice=${cowprobe}
            cow_fstype=$(get_fstype "${cowprobe}")
        else
            [ "$quiet" != "y" ] && log_warning_msg "Unable to find the persistent medium"
        fi
    fi

    mount ${cowdevice} -t ${cow_fstype} -o rw /cow || panic "Can not mount $cowdevice on /cow"

    mount -t unionfs -o dirs=/cow=rw:$rofsstring unionfs "$rootmnt" || panic "Unionfs mount failed"

    # Adding other custom mounts
    if [ ! -z "${PERSISTENT}" ]; then
        do_others_persistences
    fi

    if [ ! -z "${SHOWMOUNTS}" ]; then
        for d in ${rofslist}; do
            mkdir -p "${rootmnt}/casper/${d##*/}"
            case d in
                *.dir) # do nothing # mount -o bind "${d}" "${rootmnt}/casper/${d##*/}"
                    ;;
                *) mount -o move "${d}" "${rootmnt}/casper/${d##*/}"
                    ;;
            esac
        done
    fi

    # shows cow fs on /cow for use by casper-snapshot
    mkdir -p "$rootmnt/cow"
    mount -o bind /cow "$rootmnt/cow"
}

check_dev ()
{
    sysdev="${1}"
    devname="${2}"
    if [ -z "${devname}" ]; then
        devname=$(sys2dev "${sysdev}")
    fi
    fstype=$(get_fstype "${devname}")
    if is_supported_fs ${fstype}; then
        mount -t ${fstype} -o ro "${devname}" $mountpoint || continue
        if is_casper_path $mountpoint; then
            echo $mountpoint
            return 0
        else
            umount $mountpoint
        fi
    fi
    return 1
}

find_livefs() {
    # first look at the one specified in the command line
    if [ ! -z "${LIVEMEDIA}" ]; then
        if check_dev "null" "${LIVEMEDIA}"; then
            return 0
        fi
    fi
    # or do the scan of block devices
    for sysblock in $(echo /sys/block/* | tr ' ' '\n' | grep -v loop | grep -v ram); do
        devname=$(sys2dev "${sysblock}")
        fstype=$(get_fstype "${devname}")
        if /lib/udev/cdrom_id ${devname} > /dev/null; then
            if check_dev "null" "${devname}" ; then
                return 0
            fi
        elif is_nice_device "${sysblock}" ; then
            for dev in $(subdevices "${sysblock}"); do
                if check_dev "${dev}" ; then
                    return 0
                fi
            done
        elif [ "${fstype}" = "squashfs" -o \
                "${fstype}" = "ext3" ] -o \
                "${fstype}" = "ext2" ]; then
            # This is an ugly hack situation, the block device has
            # an image directly on it.  It's hopefully
            # casper, so take it and run with it.
            ln -s "${devname}" "${devname}.${fstype}"
            echo "${devname}.${fstype}"
            return 0
        fi
    done
    return 1
}

pulsate() {
    if [ -x /sbin/usplash_write ]; then
        /sbin/usplash_write "PULSATE"
    fi
}

set_usplash_timeout() {
    if [ -x /sbin/usplash_write ]; then
        /sbin/usplash_write "TIMEOUT 120"
    fi
}

mountroot() {
    exec 6>&1
    exec 7>&2
    exec > casper.log
    exec 2>&1

    parse_cmdline

    set_usplash_timeout
    [ "$quiet" != "y" ] && log_begin_msg "Running /scripts/casper-premount"
    pulsate
    run_scripts /scripts/casper-premount
    [ "$quiet" != "y" ] && log_end_msg

    # Needed here too because some things (*cough* udev *cough*)
    # changes the timeout

    set_usplash_timeout

    if [ ! -z "${NETBOOT}" ]; then
        if do_netmount ; then
            livefs_root="${mountpoint}"
        else
            panic "Unable to find a the network rootfs live file system"
        fi
    else
        # Scan local devices for the image
        for i in 0 1 2 3 4 5 6 7 8 9 a b c d e f 10 11 12 13; do
            livefs_root=$(find_livefs)
            if [ ! -z "${livefs_root}" ]; then
                break
            fi
            sleep 1
        done
    fi

    if [ -z "${livefs_root}" ]; then
        panic "Unable to find a medium containing a live file system"
    fi

    if [ ! -z "${TORAM}" ]; then
        copy_live_to "${livefs_root}" "ram"
    elif [ ! -z "${TODISK}" ]; then
        copy_live_to "${livefs_root}" "${TODISK}"
    fi

    mount_images_in_directory "${livefs_root}" "${rootmnt}"

    log_end_msg

    maybe_break casper-bottom
    [ "$quiet" != "y" ] && log_begin_msg "Running /scripts/casper-bottom"

    pulsate
    run_scripts /scripts/casper-bottom
    [ "$quiet" != "y" ] && log_end_msg

    exec 1>&6 6>&-
    exec 2>&7 7>&-
    cp casper.log "${rootmnt}/var/log/"
}
